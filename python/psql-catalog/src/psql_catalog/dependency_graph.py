"""
Table dependency graph analysis for psql-catalog.

This module provides functionality to analyze foreign key dependencies 
between tables and generate topologically sorted lists for safe batch operations.
"""

import json
from typing import Dict, List, Set, Tuple, Optional, Any
from collections import defaultdict, deque
from dataclasses import dataclass
from enum import Enum


class CycleDetectionError(Exception):
    """Raised when a circular dependency is detected in the table graph."""
    pass


class GraphTraversalOrder(Enum):
    """Enumeration for graph traversal orders."""
    FORWARD = "forward"   # For INSERT operations (dependencies first)
    REVERSE = "reverse"   # For DROP operations (dependents first)


@dataclass
class TableDependency:
    """Represents a dependency relationship between two tables."""
    source_table: str
    target_table: str
    constraint_name: str
    source_column: str
    target_column: str
    
    def __str__(self) -> str:
        return f"{self.source_table}({self.source_column}) -> {self.target_table}({self.target_column})"


@dataclass
class TableNode:
    """Represents a table node in the dependency graph."""
    name: str
    dependencies: Set[str]  # Tables this table depends on
    dependents: Set[str]    # Tables that depend on this table
    
    def __post_init__(self):
        if not isinstance(self.dependencies, set):
            self.dependencies = set(self.dependencies)
        if not isinstance(self.dependents, set):
            self.dependents = set(self.dependents)


class TableDependencyGraph:
    """
    Analyzes table dependencies from schema information and provides 
    topological ordering for batch database operations.
    
    This class builds a directed graph of table dependencies based on foreign
    key constraints and provides methods to traverse the graph in different orders
    suitable for various database operations like INSERT/DROP.
    """
    
    def __init__(self, schema_data: Optional[Dict[str, Any]] = None):
        """
        Initialize the dependency graph.
        
        Args:
            schema_data: Optional schema data dictionary from psql-catalog JSON output
        """
        self.nodes: Dict[str, TableNode] = {}
        self.dependencies: List[TableDependency] = []
        self._adjacency_list: Dict[str, Set[str]] = defaultdict(set)
        self._reverse_adjacency_list: Dict[str, Set[str]] = defaultdict(set)
        
        if schema_data:
            self.load_from_schema_data(schema_data)
    
    def load_from_json_file(self, json_file_path: str) -> None:
        """
        Load schema data from a JSON file generated by psql-catalog.
        
        Args:
            json_file_path: Path to the JSON file containing schema information
            
        Raises:
            FileNotFoundError: If the JSON file doesn't exist
            json.JSONDecodeError: If the JSON file is malformed
        """
        with open(json_file_path, 'r', encoding='utf-8') as f:
            schema_data = json.load(f)
        self.load_from_schema_data(schema_data)
    
    def load_from_schema_data(self, schema_data: Dict[str, Any]) -> None:
        """
        Load and analyze schema data to build the dependency graph.
        
        Args:
            schema_data: Dictionary containing schema information from psql-catalog
        """
        self.clear()
        
        # Extract tables information
        tables = schema_data.get('tables', {})
        if not tables:
            raise ValueError("No tables found in schema data")
        
        # First pass: create all table nodes
        for table_name in tables.keys():
            if table_name != '_metadata':  # Skip metadata
                self.nodes[table_name] = TableNode(
                    name=table_name,
                    dependencies=set(),
                    dependents=set()
                )
        
        # Second pass: analyze foreign key dependencies
        for table_name, table_info in tables.items():
            if table_name == '_metadata':
                continue
                
            self._analyze_table_dependencies(table_name, table_info)
        
        # Build adjacency lists for efficient traversal
        self._build_adjacency_lists()
    
    def _analyze_table_dependencies(self, table_name: str, table_info: Dict[str, Any]) -> None:
        """
        Analyze foreign key dependencies for a single table.
        
        Args:
            table_name: Name of the table to analyze
            table_info: Table information dictionary
        """
        # Check foreign_key_details first (more detailed info)
        fk_details = table_info.get('foreign_key_details', [])
        if fk_details:
            for fk in fk_details:
                target_table = fk.get('foreign_table_name')
                if target_table and target_table in self.nodes:
                    # Add dependency: table_name depends on target_table
                    self.nodes[table_name].dependencies.add(target_table)
                    self.nodes[target_table].dependents.add(table_name)
                    
                    # Create dependency object
                    dependency = TableDependency(
                        source_table=table_name,
                        target_table=target_table,
                        constraint_name=fk.get('constraint_name', ''),
                        source_column=fk.get('column_name', ''),
                        target_column=fk.get('foreign_column_name', '')
                    )
                    self.dependencies.append(dependency)
        
        # Fallback to constraints if foreign_key_details not available
        elif 'constraints' in table_info:
            constraints = table_info.get('constraints', [])
            for constraint in constraints:
                if constraint.get('constraint_type') == 'FOREIGN KEY':
                    foreign_ref = constraint.get('foreign_table_column', '')
                    if foreign_ref:
                        # Parse "schema.table.column" format
                        parts = foreign_ref.split('.')
                        if len(parts) >= 2:
                            target_table = parts[-2]  # table name
                            target_column = parts[-1]  # column name
                            
                            if target_table in self.nodes:
                                # Add dependency
                                self.nodes[table_name].dependencies.add(target_table)
                                self.nodes[target_table].dependents.add(table_name)
                                
                                # Create dependency object
                                dependency = TableDependency(
                                    source_table=table_name,
                                    target_table=target_table,
                                    constraint_name=constraint.get('constraint_name', ''),
                                    source_column=constraint.get('column_name', ''),
                                    target_column=target_column
                                )
                                self.dependencies.append(dependency)
    
    def _build_adjacency_lists(self) -> None:
        """Build adjacency lists for efficient graph traversal."""
        self._adjacency_list.clear()
        self._reverse_adjacency_list.clear()
        
        for table_name, node in self.nodes.items():
            self._adjacency_list[table_name] = node.dependencies.copy()
            for dependency in node.dependencies:
                self._reverse_adjacency_list[dependency].add(table_name)
    
    def clear(self) -> None:
        """Clear all graph data."""
        self.nodes.clear()
        self.dependencies.clear()
        self._adjacency_list.clear()
        self._reverse_adjacency_list.clear()
    
    def get_tables(self) -> List[str]:
        """Get list of all table names in the graph."""
        return list(self.nodes.keys())
    
    def get_dependencies(self, table_name: str) -> Set[str]:
        """
        Get direct dependencies of a table.
        
        Args:
            table_name: Name of the table
            
        Returns:
            Set of table names that this table depends on
        """
        return self.nodes.get(table_name, TableNode(table_name, set(), set())).dependencies
    
    def get_dependents(self, table_name: str) -> Set[str]:
        """
        Get direct dependents of a table.
        
        Args:
            table_name: Name of the table
            
        Returns:
            Set of table names that depend on this table
        """
        return self.nodes.get(table_name, TableNode(table_name, set(), set())).dependents
    
    def has_cycles(self) -> Tuple[bool, Optional[List[str]]]:
        """
        Check if the dependency graph has cycles.
        
        Returns:
            Tuple of (has_cycles, cycle_path) where cycle_path is a list
            of table names forming a cycle, or None if no cycles exist
        """
        visited = set()
        rec_stack = set()
        path = []
        
        def dfs_cycle_detection(node: str) -> bool:
            if node in rec_stack:
                # Found a cycle, extract it from path
                cycle_start = path.index(node)
                cycle_path[:] = path[cycle_start:] + [node]
                return True
            
            if node in visited:
                return False
            
            visited.add(node)
            rec_stack.add(node)
            path.append(node)
            
            for neighbor in self._adjacency_list.get(node, set()):
                if dfs_cycle_detection(neighbor):
                    return True
            
            rec_stack.remove(node)
            path.pop()
            return False
        
        cycle_path = []
        for table in self.nodes.keys():
            if table not in visited:
                if dfs_cycle_detection(table):
                    return True, cycle_path
        
        return False, None
    
    def topological_sort(self, order: GraphTraversalOrder = GraphTraversalOrder.FORWARD) -> List[str]:
        """
        Get a topologically sorted list of tables.
        
        Args:
            order: Traversal order (FORWARD for dependencies first, REVERSE for dependents first)
            
        Returns:
            List of table names in topological order
            
        Raises:
            CycleDetectionError: If circular dependencies are detected
        """
        # Check for cycles first
        has_cycles, cycle = self.has_cycles()
        if has_cycles:
            cycle_str = " -> ".join(cycle) if cycle else "unknown"
            raise CycleDetectionError(f"Circular dependency detected: {cycle_str}")
        
        # Kahn's algorithm for topological sorting
        if order == GraphTraversalOrder.FORWARD:
            # For INSERT: dependencies first
            adjacency = self._adjacency_list
            in_degree = {table: len(deps) for table, deps in adjacency.items()}
        else:
            # For DROP: dependents first (reverse the graph)
            adjacency = self._reverse_adjacency_list
            in_degree = {table: len(deps) for table, deps in adjacency.items()}
        
        # Initialize queue with nodes that have no dependencies
        queue = deque([table for table, degree in in_degree.items() if degree == 0])
        result = []
        
        while queue:
            current = queue.popleft()
            result.append(current)
            
            # Update in-degrees of neighbors
            for neighbor in adjacency.get(current, set()):
                in_degree[neighbor] -= 1
                if in_degree[neighbor] == 0:
                    queue.append(neighbor)
        
        # Sanity check
        if len(result) != len(self.nodes):
            remaining = set(self.nodes.keys()) - set(result)
            raise CycleDetectionError(f"Unable to sort all tables. Remaining: {remaining}")
        
        return result
    
    def get_insert_order(self) -> List[str]:
        """
        Get table names ordered for safe INSERT operations.
        Tables with no dependencies come first.
        
        Returns:
            List of table names in INSERT order
        """
        return self.topological_sort(GraphTraversalOrder.FORWARD)
    
    def get_drop_order(self) -> List[str]:
        """
        Get table names ordered for safe DROP operations.
        Tables with no dependents come first.
        
        Returns:
            List of table names in DROP order
        """
        return self.topological_sort(GraphTraversalOrder.REVERSE)
    
    def get_dependency_info(self) -> Dict[str, Dict[str, Any]]:
        """
        Get detailed dependency information for all tables.
        
        Returns:
            Dictionary with table names as keys and dependency info as values
        """
        return {
            table_name: {
                'dependencies': list(node.dependencies),
                'dependents': list(node.dependents),
                'dependency_count': len(node.dependencies),
                'dependent_count': len(node.dependents)
            }
            for table_name, node in self.nodes.items()
        }
    
    def print_graph_summary(self) -> None:
        """Print a summary of the dependency graph."""
        print(f"Table Dependency Graph Summary:")
        print(f"  Total tables: {len(self.nodes)}")
        print(f"  Total dependencies: {len(self.dependencies)}")
        
        has_cycles, cycle = self.has_cycles()
        if has_cycles:
            cycle_str = " -> ".join(cycle) if cycle else "unknown"
            print(f"  ⚠️  Circular dependencies detected: {cycle_str}")
        else:
            print(f"  ✓ No circular dependencies")
        
        # Show tables with no dependencies (root nodes)
        root_tables = [name for name, node in self.nodes.items() if len(node.dependencies) == 0]
        if root_tables:
            print(f"  Root tables (no dependencies): {', '.join(sorted(root_tables))}")
        
        # Show tables with no dependents (leaf nodes)
        leaf_tables = [name for name, node in self.nodes.items() if len(node.dependents) == 0]
        if leaf_tables:
            print(f"  Leaf tables (no dependents): {', '.join(sorted(leaf_tables))}")
    
    def print_detailed_dependencies(self) -> None:
        """Print detailed dependency information for each table."""
        print("\nDetailed Table Dependencies:")
        print("-" * 50)
        
        for table_name in sorted(self.nodes.keys()):
            node = self.nodes[table_name]
            print(f"\nTable: {table_name}")
            
            if node.dependencies:
                print(f"  Depends on: {', '.join(sorted(node.dependencies))}")
            else:
                print(f"  Depends on: (none)")
            
            if node.dependents:
                print(f"  Depended by: {', '.join(sorted(node.dependents))}")
            else:
                print(f"  Depended by: (none)")
        
        if self.dependencies:
            print(f"\nForeign Key Relationships:")
            print("-" * 30)
            for dep in self.dependencies:
                print(f"  {dep}")


def analyze_schema_file(json_file_path: str) -> TableDependencyGraph:
    """
    Analyze a schema JSON file and return a dependency graph.
    
    Args:
        json_file_path: Path to the JSON file generated by psql-catalog
        
    Returns:
        TableDependencyGraph instance with loaded data
        
    Example:
        >>> graph = analyze_schema_file('my_schema.json')
        >>> insert_order = graph.get_insert_order()
        >>> drop_order = graph.get_drop_order()
    """
    graph = TableDependencyGraph()
    graph.load_from_json_file(json_file_path)
    return graph


# Convenience functions for common operations
def get_table_insert_order(json_file_path: str) -> List[str]:
    """Get table names in INSERT order from schema JSON file."""
    graph = analyze_schema_file(json_file_path)
    return graph.get_insert_order()


def get_table_drop_order(json_file_path: str) -> List[str]:
    """Get table names in DROP order from schema JSON file."""
    graph = analyze_schema_file(json_file_path)
    return graph.get_drop_order()


def print_dependency_analysis(json_file_path: str) -> None:
    """Print complete dependency analysis from schema JSON file."""
    graph = analyze_schema_file(json_file_path)
    graph.print_graph_summary()
    graph.print_detailed_dependencies()
    
    print(f"\nRecommended Operation Orders:")
    print("-" * 30)
    
    try:
        insert_order = graph.get_insert_order()
        print(f"INSERT order: {' -> '.join(insert_order)}")
        
        drop_order = graph.get_drop_order()
        print(f"DROP order: {' -> '.join(drop_order)}")
    except CycleDetectionError as e:
        print(f"❌ Cannot generate operation orders: {e}")


if __name__ == "__main__":
    import sys
    
    if len(sys.argv) != 2:
        print("Usage: python dependency_graph.py <schema.json>")
        sys.exit(1)
    
    json_file = sys.argv[1]
    print_dependency_analysis(json_file)
